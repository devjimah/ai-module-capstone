/**
 * Task Routes — CRUD Handlers
 * =====================================================
 * STAGE 2 OUTPUT — Generated by IDE AI from api_spec.json
 *
 * Each route handler corresponds to an operationId from
 * the OpenAPI spec paths:
 *   GET    /tasks       → listTasks
 *   POST   /tasks       → createTask
 *   GET    /tasks/:id   → getTask
 *   PUT    /tasks/:id   → updateTask
 *   DELETE /tasks/:id   → deleteTask
 * =====================================================
 */

const express = require("express");
const { v4: uuidv4 } = require("uuid");
const {
  createTaskSchema,
  updateTaskSchema,
  listTasksQuerySchema,
} = require("../validation");

const router = express.Router();

// In-memory store (replaces DB for demo purposes)
const tasks = new Map();

/**
 * GET /tasks — listTasks
 * Query params: status, priority (from OpenAPI parameters)
 */
router.get("/", (req, res) => {
  const { error, value } = listTasksQuerySchema.validate(req.query);
  if (error) {
    return res.status(400).json({
      error: "ValidationError",
      message: error.details[0].message,
      details: error.details,
    });
  }

  let result = Array.from(tasks.values());

  if (value.status) {
    result = result.filter((t) => t.status === value.status);
  }
  if (value.priority) {
    result = result.filter((t) => t.priority === value.priority);
  }

  res.json(result);
});

/**
 * POST /tasks — createTask
 * Request body validated against CreateTaskInput schema
 */
router.post("/", (req, res) => {
  const { error, value } = createTaskSchema.validate(req.body, {
    abortEarly: false,
  });

  if (error) {
    return res.status(400).json({
      error: "ValidationError",
      message: error.details.map((d) => d.message).join("; "),
      details: error.details,
    });
  }

  const now = new Date().toISOString();
  const task = {
    id: uuidv4(),
    title: value.title,
    description: value.description || "",
    status: "pending",
    priority: value.priority || "medium",
    assignee: value.assignee || null,
    dueDate: value.dueDate ? new Date(value.dueDate).toISOString() : null,
    createdAt: now,
    updatedAt: now,
  };

  tasks.set(task.id, task);
  res.status(201).json(task);
});

/**
 * GET /tasks/:taskId — getTask
 * Path parameter: taskId (from OpenAPI parameters)
 */
router.get("/:taskId", (req, res) => {
  const task = tasks.get(req.params.taskId);

  if (!task) {
    return res.status(404).json({
      error: "NotFound",
      message: `Task with ID '${req.params.taskId}' not found`,
    });
  }

  res.json(task);
});

/**
 * PUT /tasks/:taskId — updateTask
 * Request body validated against UpdateTaskInput schema
 */
router.put("/:taskId", (req, res) => {
  const task = tasks.get(req.params.taskId);

  if (!task) {
    return res.status(404).json({
      error: "NotFound",
      message: `Task with ID '${req.params.taskId}' not found`,
    });
  }

  const { error, value } = updateTaskSchema.validate(req.body, {
    abortEarly: false,
  });

  if (error) {
    return res.status(400).json({
      error: "ValidationError",
      message: error.details.map((d) => d.message).join("; "),
      details: error.details,
    });
  }

  // Apply updates
  Object.keys(value).forEach((key) => {
    task[key] = value[key];
  });
  task.updatedAt = new Date().toISOString();

  tasks.set(task.id, task);
  res.json(task);
});

/**
 * DELETE /tasks/:taskId — deleteTask
 * Returns 204 on success, 404 if not found
 */
router.delete("/:taskId", (req, res) => {
  if (!tasks.has(req.params.taskId)) {
    return res.status(404).json({
      error: "NotFound",
      message: `Task with ID '${req.params.taskId}' not found`,
    });
  }

  tasks.delete(req.params.taskId);
  res.status(204).send();
});

// Export for testing — allows resetting the store
router._tasks = tasks;

module.exports = router;
